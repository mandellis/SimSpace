//! ----------------
//! custom includes
//! ----------------
#include "nettgentool2.h"
#include <ng_meshvs_datasourceface.h>
#include <ng_meshvs_datasource2d.h>
#include <ng_meshvs_datasource3d.h>
#include <qprogressevent.h>
#include <qprogressindicator.h>

//! ----
//! OCC
//! ----
#include <Bnd_Box.hxx>
#include <BRepBndLib.hxx>

#include <TopExp.hxx>
#include <TopoDS_Face.hxx>
#include <TopoDS_Edge.hxx>
#include <TopoDS_Shape.hxx>
#include <TopoDS.hxx>
#include <TopAbs_ShapeEnum.hxx>
#include <TopTools_IndexedMapOfShape.hxx>
#include <TColStd_MapIteratorOfPackedMapOfInteger.hxx>

#include <BRep_Tool.hxx>
#include <BRepAdaptor_Curve.hxx>
#include <BRepAdaptor_Surface.hxx>
#include <GeomAdaptor_Surface.hxx>
#include <GeomAdaptor_Curve.hxx>
#include <Geom_Surface.hxx>
#include <Geom_Curve.hxx>
#include <BRepTools.hxx>
#include <CPnts_AbscissaPoint.hxx>
#include <gp_Pnt.hxx>

#include <MeshVS_DataSource.hxx>

//! ---
//! Qt
//! ---
#include <QApplication>

//! ----
//! C++
//! ----
#include <vector>
#include <set>
#include <map>
#include <algorithm>

//! -------
//! global
//! -------
#include "global.h"

//! ----------------------
//! function: constructor
//! detail:
//! ----------------------
NettgenTool2::NettgenTool2(QObject *parent):QObject(parent)
{
    myProgressIndicator = Q_NULLPTR;
    this->setObjectName("netgenSTLmesher");
}

//! -----------------------------------
//! function: perform
//! details:  works on an STL geometry
//! -----------------------------------
userMessage NettgenTool2::perform(int bodyIndex,
                                  bool isVolume,
                                  occHandle(MeshVS_DataSource) &outputSurfaceMeshDS,
                                  occHandle(MeshVS_DataSource) &outputVolumeMeshDS,
                                  std::vector<vector<double>> &vecUnassociatedElements)
{
    userMessage mr(false,"");

    //! ----------------------
    //! send a progress event
    //! ----------------------
    QString task = "Netgen meshing";
    QProgressEvent *progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",QProgressEvent_Init,0,100,0,task);
    QApplication::postEvent(myProgressIndicator,progressEvent);

    //! -------------------------------------------------------------
    //! scan the face mesh data sources
    //! here they are intended to be generated by a tessellator
    //! if, for some reason, a face has not a valid stl mesh it
    //! will be discarded, and considered as invalid
    //! The vector "faceTags" vector will contains the face tags
    //! of the valid faces. "tessellation" is the final tessellation
    //! -------------------------------------------------------------
    cout<<"NetgenTool2::perform()->____start retrieving tessellation from the mesh data base____"<<endl;
    std::vector<Ng_STLTriangle> tessellation;

    int NbFaces = myMDB->MapOfBodyTopologyMap.value(bodyIndex).faceMap.Extent();

    //FILE *f = fopen("D:\\triangleToFaceNumber_WB.txt","w");

    //! ------------------------------
    //! key: hash of the STL triangle
    //! value: face number
    //! ------------------------------
    QMap<size_t,int> trigSTLhashFaceNrMap;

    std::vector<int> faceTags;
    for(int faceNr = 0; faceNr<=NbFaces; faceNr++)
    {
        const occHandle(MeshVS_DataSource) &meshDS = myMDB->ArrayOfMeshDSOnFaces.getValue(bodyIndex,faceNr);
        if(meshDS.IsNull()) continue;
        //cout<<"NetgenTool2::perform()->____the face: "<<faceNr<<" is valid____"<<endl;
        faceTags.push_back(faceNr);

        //! -------------------------------------------
        //! retrieve the tessellation of the face:
        //! scan all the triangles of the current mesh
        //! -------------------------------------------
        MeshVS_EntityType type;
        int NbNodes, s;
        double buf[9];
        TColStd_Array1OfReal coords(*buf,1,9);
        for(TColStd_MapIteratorOfPackedMapOfInteger it(meshDS->GetAllElements()); it.More(); it.Next())
        {
            int globalElementID = it.Key();
            bool isOK = meshDS->GetGeom(globalElementID,true,coords,NbNodes,type);
            if(!isOK) continue;
            std::vector<double> trianglePoints;

            //! --------------------------
            //! hash code of the triangle
            //! --------------------------
            size_t seed = 0;

            //fprintf(f, "----start----\n");
            for(int n=0; n<NbNodes; n++)
            {
                s=3*n;
                trianglePoints.push_back(coords(s+1));
                trianglePoints.push_back(coords(s+2));
                trianglePoints.push_back(coords(s+3));

                //! ------------------------------------------------------
                //! generate a hash code for the current STL the triangle
                //! ------------------------------------------------------
                hash_c<double>(seed,coords(s+1));
                hash_c<double>(seed,coords(s+2));
                hash_c<double>(seed,coords(s+3));
                //fprintf(f,"%lf\t%lf\t%lf\n",coords(s+1),coords(s+2),coords(s+3));
            }
            //! -------------------------------------------------
            //! put the hash code of the STL triangle into a map
            //! -------------------------------------------------
            trigSTLhashFaceNrMap.insert(seed,faceNr);

            //fprintf(f,"%zd\t%d\n",seed,faceNr);
            //fprintf(f, "----end----\n");

                //! ------------------------------------------------
            //! build a triangle and add it to the tessellation
            //! ------------------------------------------------
            Ng_STLTriangle aSTLTriangle(trianglePoints,faceNr);
            tessellation.push_back(aSTLTriangle);
        }
    }

    //fclose(f);

    cout<<"NetgenTool2::perform()->____number of tessellation triangles: "<<tessellation.size()<<"____"<<endl;

    //! --------------------------------------
    //! prepare the external edges for netgen
    //! --------------------------------------
    cout<<"NetgenTool2::perform()->____start retrieving the mesh edges____"<<endl;
    std::vector<std::pair<std::vector<double>, std::vector<double>>> vecEdges;
    //QList<Ng_MeshVS_DataSourceFace::meshSegment> allSegments;
    QList<mesh::meshSegment> allSegments;
    for(int faceNr = 0; faceNr<=NbFaces; faceNr++)
    {
        const occHandle(MeshVS_DataSource) &meshDS = myMDB->ArrayOfMeshDSOnFaces.getValue(bodyIndex,faceNr);
        if(meshDS.IsNull()) continue;
        occHandle(Ng_MeshVS_DataSourceFace) curFaceMesh = occHandle(Ng_MeshVS_DataSourceFace)::DownCast(meshDS);

        if(curFaceMesh->myBoundarySegments.size()==0) curFaceMesh->computeFreeMeshSegments();

        //! ----------------------------------------
        //! mesh segments of the face mesh boundary
        //! ----------------------------------------
        int NbSegments = int(curFaceMesh->myBoundarySegments.size());
        for(int nseg=0; nseg<NbSegments; nseg++)
        {
            //Ng_MeshVS_DataSourceFace::meshSegment aMeshSegment =  curFaceMesh->myBoundarySegments.at(nseg);
            mesh::meshSegment aMeshSegment =  curFaceMesh->myBoundarySegments.at(nseg);
            if(!allSegments.contains(aMeshSegment)) allSegments<<aMeshSegment;
        }
        //cout<<"NetgenTool2::perform()->____number of mesh edges on the face "<<faceNr<<" boundary: "<<NbSegments<<"____"<<endl;
    }

    //! -------------------------
    //! surface mesh data source
    //! -------------------------
    const occHandle(Ng_MeshVS_DataSource2D) &surfaceMeshDS =
            occHandle(Ng_MeshVS_DataSource2D)::DownCast(myMDB->ArrayOfMeshDS2D.value(bodyIndex));

    for(int i=0; i<allSegments.length(); i++)
    {
        //const Ng_MeshVS_DataSourceFace::meshSegment &aSegment = allSegments.at(i);
        const mesh::meshSegment &aSegment = allSegments.at(i);

        int firstIndex = aSegment.nodeIDs.at(0);
        int secondIndex = aSegment.nodeIDs.at(1);
        const std::vector<double> &P1 = surfaceMeshDS->getNodeCoordinates(surfaceMeshDS->myNodesMap.FindIndex(firstIndex));
        const std::vector<double> &P2 = surfaceMeshDS->getNodeCoordinates(surfaceMeshDS->myNodesMap.FindIndex(secondIndex));
        std::pair<std::vector<double>,std::vector<double>> segment;
        segment.first = P1;
        segment.second = P2;
        vecEdges.push_back(segment);
        //vecEdges.push_back(std::make_pair<std::vector<double>,std::vector<double>>(P1,P1));
    }

    //cout<<"NetgenTool2::perform()->____number of boundary mesh segments: "<<vecEdges.size()<<"____"<<endl;

    //! -----------------------------------------------------------
    //! init the meshing parameters
    //! the global meshing parameters read from the mesh data base
    //! -----------------------------------------------------------
    Ng_Meshing_Parameters mp = initNetgenMeshingParameters();

    mp.grading = myMDB->ArrayOfGradingValue.value(bodyIndex);
    mp.minh = myMDB->ArrayOfMinBodyElementSize.value(bodyIndex);
    mp.maxh = myMDB->ArrayOfMaxBodyElementSize.value(bodyIndex);

    cout<<"\\----------------------------------------------------------------------\\"<<endl;
    cout<<"\\- meshing parameters from interface                                   \\"<<endl;
    cout<<"\\- grading = "<<mp.grading<<endl;
    cout<<"\\- minh = "<<mp.minh<<endl;
    cout<<"\\- maxh = "<<mp.maxh<<endl;

    // remember to connect the optimization steps ... to do

    //! -------------------------------------------------------------------------
    //! workaround - all the faces in the geometry data base are incredibly null
    //! and so all the other sub-geometries
    //! -------------------------------------------------------------------------
    const TopoDS_Shape &curBody = myMDB->bodyMap.value(bodyIndex);
    TopTools_IndexedMapOfShape faceMap;
    TopTools_IndexedMapOfShape edgeMap;
    TopTools_IndexedMapOfShape vertexMap;
    TopExp::MapShapes(curBody,TopAbs_FACE,faceMap);
    TopExp::MapShapes(curBody,TopAbs_EDGE,edgeMap);
    TopExp::MapShapes(curBody,TopAbs_VERTEX,vertexMap);

    //! ----------------------------------------------------------------------------
    //! a "local" (i.e. defined on a sub-geometry) mesh control is defined through
    //! a vector of sampled point on that subgeometry and by the element size value
    //! ----------------------------------------------------------------------------
    std::vector<std::pair<std::vector<std::vector<double>>,double>> meshControls;
    for(int faceNr = 1; faceNr<=NbFaces; faceNr++)
    {
        bool isMeshControlOnFace = myMDB->MapOfIsFaceModified.getValue(bodyIndex,faceNr);
        if(isMeshControlOnFace)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- face mesh control on face: "<<faceNr<<" is: "<<(isMeshControlOnFace? "ON":"OFF")<<" => ";
            double maxElementSize = myMDB->MapOfElementSizeOnFace.getValue(bodyIndex,faceNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;

            //! ------------------------------------------------------
            //! parameters for sampling - a vector of double
            //! here only one value, i.e. the face sizing on the face
            //! ------------------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(maxElementSize);
            parametersForSampling.setValue(parameters);

            const TopoDS_Shape &curFace = faceMap.FindKey(faceNr);
            std::vector<std::vector<double>> sampledPoints;
            this->sampleGeometry(curFace,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
        }
    }

    int NbEdges = myMDB->MapOfBodyTopologyMap.value(bodyIndex).edgeMap.Extent();
    for(int edgeNr = 1; edgeNr<=NbEdges; edgeNr++)
    {
        bool isMeshControlOnEdge = myMDB->MapOfIsEdgeModified.getValue(bodyIndex,edgeNr);
        if(isMeshControlOnEdge)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- edge mesh control on edge: "<<edgeNr<<" is: "<<(isMeshControlOnEdge? "ON":"OFF")<<" => ";
            double maxElementSize = myMDB->MapOfElementSizeOnEdge.getValue(bodyIndex,edgeNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;
            const TopoDS_Shape &curEdge = edgeMap.FindKey(edgeNr);
            std::vector<std::vector<double>> sampledPoints;

            //! ---------------------------------------------
            //! parameters for sampling - a vector of double
            //! here only one value, i.e. the edge sizing
            //! ---------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(maxElementSize);
            parametersForSampling.setValue(parameters);

            this->sampleGeometry(curEdge,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
        }
    }

    int NbVertices = myMDB->MapOfBodyTopologyMap.value(bodyIndex).vertexMap.Extent();
    for(int vertexNr = 1; vertexNr<=NbVertices; vertexNr++)
    {
        bool isMeshControlOnVertex = myMDB->MapOfIsVertexModified.getValue(bodyIndex,vertexNr);
        if(isMeshControlOnVertex)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- vertex mesh control on vertex: "<<vertexNr<<" is: "<<(isMeshControlOnVertex? "ON":"OFF")<<" => ";

            double maxElementSize = myMDB->MapOfElementSizeOnVertex.getValue(bodyIndex,vertexNr);
            double pinball = myMDB->MapOfVertexPinball.getValue(bodyIndex,vertexNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;
            //cout<<"____pinball: "<<pinball<<"____"<<endl;

            //! ---------------------------------------------
            //! parameters for sampling - a vector of double
            //! here pinball value
            //! ---------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(pinball);
            parametersForSampling.setValue(parameters);

            const TopoDS_Shape &curVertex = vertexMap.FindKey(vertexNr);
            std::vector<std::vector<double>> sampledPoints;
            this->sampleGeometry(curVertex,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
         }
    }

    cout<<"\\----------------------------------------------------------------------\\"<<endl;

    void *localMeshSizingControls = (void*)(&meshControls);

    //! --------------------
    //! netgen/nglib inputs
    //! --------------------
    void *netgenTessellation = (void*)(&tessellation);

    //! -------------------------------------------------
    //! test - avoid the use of externally defined edges
    //! -------------------------------------------------
    //vecEdges.clear();
    void *externallyDefinedEdges = (void*)(&vecEdges);

    //! -------------------------
    //! output of the nglib call
    //! -------------------------
    bool isDone = false;

    //! -----------------------------------
    //! the meshing results - surface mesh
    //! -----------------------------------
    std::vector<Ng_meshPoint> surfaceMeshPoints;
    void *surfaceMeshPointsP = (void*)(&surfaceMeshPoints);
    std::vector<Ng_surfaceMeshElement> surfaceMeshElements;
    void *surfaceMeshElementsP = (void*)(&surfaceMeshElements);

    //! ----------------------------------
    //! the meshing results - volume mesh
    //! ----------------------------------
    std::vector<Ng_meshPoint> volumeMeshPoints;
    void *volumeMeshPointsP = (void*)(&volumeMeshPoints);
    std::vector<Ng_volumeMeshElement> volumeMeshElements;
    void *volumeMeshElementsP = (void*)(&volumeMeshElements);

    //! -----------------------------------------------------------
    //! key:   surface element generated by netgen
    //! value: hash of the STL triangle on which the elemente lies
    //! -----------------------------------------------------------
    std::map<Ng_surfaceMeshElement,size_t> surfaceMeshData;
    void *surfaceMeshDataP = (void*)(&surfaceMeshData);

    //! ---------------------------------------------------------
    //! "pending" mesh elements - this is a returning value
    //! surface elements generated by Netgen which cannot be
    //! associated to any face by the heuristic inside nglib.dll
    //! ---------------------------------------------------------
    //std::vector<std::vector<double>> vecUnassociatedElements;
    void *unassociatedElements = (void*)(&vecUnassociatedElements);

#ifndef HANDLE_NGLIB_SYSTEM_EXCEPTIONS
    //! ------------------------------------------------------------
    //! the main call for generating the surface or the volume mesh
    //! ------------------------------------------------------------
    isDone = Ng_STL_buildMesh(isVolume,
                              netgenTessellation,
                              externallyDefinedEdges,
                              &mp,
                              localMeshSizingControls,
                              surfaceMeshPointsP,
                              surfaceMeshElementsP,
                              volumeMeshPointsP,
                              volumeMeshElementsP,
                              surfaceMeshDataP);
#endif

#ifdef HANDLE_NGLIB_SYSTEM_EXCEPTIONS
    STLMeshing_InOutParameters m;
    m.isVolume = isVolume;
    m.netgenTessellation = netgenTessellation;
    m.externallyDefinedEdges = externallyDefinedEdges;
    m.meshingParameters = &mp;
    m.localMeshSizingControls = localMeshSizingControls;
    m.surfaceMeshPointsP = surfaceMeshPointsP;
    m.surfaceMeshElementsP = surfaceMeshElementsP;
    m.volumeMeshPointsP = volumeMeshPointsP;
    m.volumeMeshElementsP = volumeMeshElementsP;
    m.surfaceMeshDataP = surfaceMeshDataP;
    m.unassociatedSurfaceElements = unassociatedElements;

    try
    {
        emit requestStartingNetgenEnquireTimer();
        _set_se_translator(trans_func_N);
        isDone = this->SystemErrorFunction(m);
    }
    catch(SE_Exception)
    {
        cout<<"NettgenTool2::perform()->____a netgen system error has been captured____"<<endl;
        emit requestStoppingNetgenEnquireTimer();
        mr.isDone = false;
        mr.message = QString("Netgen STL meshing failure");
        return mr;
    }
#endif

    cout<<"NetgenTool2::perform()->____EXITING NGLIB: "<<isDone<<"____"<<endl;

    if(!isDone)
    {
        mr.isDone = false;
        mr.message = QString("Netgen STL meshing failure");
        return mr;
    }

    if(isVolume)
    {
        cout<<"NettgenTool2::perform()->____number of volume mesh points: "<<volumeMeshPoints.size()<<"____"<<endl;
        cout<<"NettgenTool2::perform()->____number of volume mesh elements: "<<volumeMeshElements.size()<<"____"<<endl;
    }

    //! -----------------------------
    //! convert into mesh::meshPoint
    //! and into mesh::meshElement
    //! -----------------------------
    std::vector<mesh::meshPoint> vecSurfaceMeshPoints;
    for(int n = 0; n<surfaceMeshPoints.size(); n++)
    {
        const Ng_meshPoint &nmp = surfaceMeshPoints.at(n);
        mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
        vecSurfaceMeshPoints.push_back(aMeshPoint);
    }

    std::vector<mesh::meshElement> vecSurfaceMeshElements;
    for(int n=0; n<surfaceMeshElements.size(); n++)
    {
        const Ng_surfaceMeshElement &nme = surfaceMeshElements[n];
        mesh::meshElement aSurfaceMeshElement;
        int NbNodes = 0;

        switch(nme.type)
        {
        case NG_TRIG: NbNodes = 3; aSurfaceMeshElement.type = TRIG; break;
        case NG_TRIG6: NbNodes = 6; aSurfaceMeshElement.type = TRIG6; break;
        case NG_QUAD: NbNodes = 4; aSurfaceMeshElement.type = QUAD; break;
        case NG_QUAD6: NbNodes = 6; aSurfaceMeshElement.type = QUAD6; break;
        case NG_QUAD8: NbNodes = 8; aSurfaceMeshElement.type = QUAD8; break;
        }
        //! ----------------------
        //! add the element nodes
        //! ----------------------
        for(int k=0; k<NbNodes; k++)
        {
            int nodeID = nme.nodeIDs.at(k);
            aSurfaceMeshElement.theNodeIDs.push_back(nodeID);
        }
        aSurfaceMeshElement.ID = n+1;
        vecSurfaceMeshElements.push_back(aSurfaceMeshElement);
    }

    //! -----------------------------------
    //! build the surface mesh data source
    //! -----------------------------------
    outputSurfaceMeshDS = new Ng_MeshVS_DataSource2D(vecSurfaceMeshElements, vecSurfaceMeshPoints);
    if(outputSurfaceMeshDS.IsNull())
    {
        mr.isDone = false;
        mr.message = "Cannot generate the surface mesh data source";
        return mr;
    }

    //! ------------------------------------------------------
    //! stop the Netgen enquire timer
    //! (if this point has been reached, it means that netgen
    //! has finished generating the surface mesh)
    //! ------------------------------------------------------
    emit requestStoppingNetgenEnquireTimer();

    //! ---------------------------------------
    //! post "Init" event on the secondary bar
    //! dpgr: progress increment step
    //! ---------------------------------------
    int pgr = 0;
    int finalPgr =int(surfaceMeshData.size());
    //!int dpgr = int(double(finalPgr)/10.0);       //! every 10%
    int dpgr = 100;                                 //! every 100 triangles
    task = "Netgen rebuilding associativity";
    progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",QProgressEvent_Init,0,finalPgr,0,task);
    QApplication::postEvent(myProgressIndicator,progressEvent);
    QApplication::processEvents();

    this->clock();

    //! -----------------------------------------------------
    //! rebuild the mesh element - face number associativity
    //! build the face mesh data sources
    //! -----------------------------------------------------
    QMap<int,mesh::meshElement> mm;
    QMap<int,std::vector<mesh::meshElement>> faceSubMeshElementMap;
    for(std::map<Ng_surfaceMeshElement,size_t>::iterator it = surfaceMeshData.begin(); it!=surfaceMeshData.end(); it++)
    {
        if(Global::status().code == 0)
        {
            //! ---------------------------------------------
            //! post a progress event signaling interruption
            //! ---------------------------------------------
            int curProg = myProgressIndicator->getCurrentProgress1();
            progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"Meshing process interrupted by the user",
                                               QProgressEvent_Update,0,9999,curProg,"");
            QApplication::postEvent(myProgressIndicator,progressEvent);
            QApplication::processEvents();

            mr.isDone = false;
            mr.message = QString("Meshing process interrupted by the user");
            return mr;
        }

        std::pair<Ng_surfaceMeshElement,size_t> aPair = *it;
        const Ng_surfaceMeshElement &netgenSurfaceMeshElement = aPair.first;

        //! --------------------------------------------------------------
        //! this is the hash code of the STL triangle generated by netgen
        //! --------------------------------------------------------------
        const size_t &trigHash = aPair.second;
        int faceNr = trigSTLhashFaceNrMap.value(trigHash,-1);
        if(faceNr == -1)
        {
            //! ------------------------------------------
            //! this part of code should never be reached
            //! ------------------------------------------
            cerr<<"NetgenTool2::perform()->____error in retrieving the STL triangle from the map____"<<endl;
            //exit(10);
            continue;
        }
        //! ---------------------------------------------------------------
        //! convert the current netgen mesh element into mesh::meshElement
        //! ---------------------------------------------------------------
        mesh::meshElement aMeshElement;
        int NbNodes = 0;
        switch(netgenSurfaceMeshElement.type)
        {
        case NG_TRIG: NbNodes = 3; aMeshElement.type = TRIG; break;
        case NG_QUAD: NbNodes = 4; aMeshElement.type = QUAD; break;
        case NG_TRIG6: NbNodes = 6; aMeshElement.type = TRIG6; break;
        case NG_QUAD6: NbNodes = 6; aMeshElement.type = QUAD6; break;
        case NG_QUAD8: NbNodes = 8; aMeshElement.type = QUAD8; break;
        }
        for(int j=0; j<NbNodes; j++) aMeshElement.theNodeIDs.push_back(netgenSurfaceMeshElement.nodeIDs[j]);
        aMeshElement.ID = netgenSurfaceMeshElement.elementID;
        /*
        //! -------------------------------------------------------------
        //! group the surface mesh elements according to the face number
        //! -------------------------------------------------------------
        if(faceSubMeshElementMap.contains(faceNr))
        {
            std::vector<mesh::meshElement> fme = faceSubMeshElementMap.value(faceNr);
            fme.push_back(aMeshElement);
            faceSubMeshElementMap.insert(faceNr,fme);
        }
        else
        {
            std::vector<mesh::meshElement> fme{aMeshElement};
            faceSubMeshElementMap.insert(faceNr,fme);
        }
        */
        //! -------------
        //! experimental
        //! -------------
        mm.insertMulti(faceNr,aMeshElement);

        //! ----------------------
        //! post a progress event
        //! ----------------------
        pgr++;
        if(pgr%dpgr==10)
        {
            progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"Rebuilding surface elements associativity",
                                               QProgressEvent_Update,0,finalPgr-1,pgr,task);
            QApplication::postEvent(myProgressIndicator,progressEvent);
            QApplication::processEvents();
        }
    }
    //! -------------
    //! experimental
    //! -------------
    int oldFaceNr = -1;
    QList<int> listOfKeys = mm.keys();
    for(int k = 0 ; k<listOfKeys.length(); k++)
    {
        int faceNr = listOfKeys[k];
        if(faceNr == oldFaceNr) continue;

        //cout<<"____processing face nr: "<<faceNr<<"____"<<endl;

        const QList<mesh::meshElement> &l = mm.values(faceNr);
        int NbElements = l.length();
        if(NbElements==0) continue;

        std::vector<mesh::meshElement> v;
        for(QList<mesh::meshElement>::const_iterator it=l.cbegin(); it!=l.cend(); it++) v.push_back(*it);
        faceSubMeshElementMap.insert(faceNr,v);
        oldFaceNr = faceNr;
    }
    //! -----------------
    //! end experimental
    //! -----------------
    this->clock();

    //! ------------------------------------------------------------
    //! post a progress event (end of associativity reconstruction)
    //! ------------------------------------------------------------
    if(myProgressIndicator!=Q_NULLPTR)
    {
        progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",
                                           QProgressEvent_Reset,0,100,0,task);
        QApplication::postEvent(myProgressIndicator,progressEvent);
        QApplication::processEvents();
    }

    //! ------------------------------------------------------------------------
    //! The "Ceasar's function"
    //! this function creates the face mesh data sources from the Netgen output
    //! ------------------------------------------------------------------------
    for(QMap<int,std::vector<mesh::meshElement>>::iterator it =faceSubMeshElementMap.begin(); it!=faceSubMeshElementMap.end(); it++)
    {
        //! ------------------
        //! check termination
        //! ------------------
        if(Global::status().code==0)
        {
            mr.isDone = false;
            mr.message = "Netgen meshing process interrupted by the user when generatin the face mesh data sources";
            return mr;
        }

        int faceNr = it.key();
        std::vector<mesh::meshElement> faceMeshElements = it.value();

        //! use std::set for unique nodeID values
        //std::set<int> uniqueNodeIDs;  //[2]

        //! use std::find
        std::vector<int> uniqueNodeIDs; //[1]

        for(std::vector<mesh::meshElement>::iterator eIt = faceMeshElements.begin(); eIt!=faceMeshElements.end(); eIt++)
        {
            const mesh::meshElement &aMeshElement = *eIt;
            int NbNodes = int(aMeshElement.theNodeIDs.size());
            for(int n=0; n<NbNodes; n++)
            {
                int nodeID = aMeshElement.theNodeIDs[n];
                if(std::find(uniqueNodeIDs.begin(), uniqueNodeIDs.end(), nodeID)==uniqueNodeIDs.end())
                    uniqueNodeIDs.push_back(nodeID);  //[1]

                //uniqueNodeIDs.insert(nodeID); //[2]
            }
        }

        std::vector<mesh::meshPoint> vecFaceMeshPoints;

        for(std::vector<int>::iterator nIt = uniqueNodeIDs.begin(); nIt!=uniqueNodeIDs.end(); nIt++)  //[1]
        //for(std::set<int>::iterator nIt = uniqueNodeIDs.begin(); nIt!=uniqueNodeIDs.end(); nIt++)       //[2]
        {
            int nodeID = *nIt;
            const mesh::meshPoint &aMeshPoint = vecSurfaceMeshPoints.at(nodeID-1);
            vecFaceMeshPoints.push_back(aMeshPoint);
        }

        //! -----------------------------------------
        //! actually build the face mesh data source
        //! and put it into the mesh data base
        //! -----------------------------------------
        occHandle(Ng_MeshVS_DataSourceFace) faceMeshDS = new Ng_MeshVS_DataSourceFace(faceMeshElements,vecFaceMeshPoints);
        myMDB->ArrayOfMeshDSOnFaces.setValue(bodyIndex,faceNr,faceMeshDS);
    }
    //! -------------------------------
    //! end of the "Ceasar's function"
    //! -------------------------------

    //! -------------------------------
    //! handling unassociated elements
    //! -------------------------------
    if(vecUnassociatedElements.empty()==false)
    {
        cout<<"********************************************************************"<<endl;
        cout<<" start handling pending nodes"<<endl;
        cout<<" generating the hash table of the points of the surface mesh"<<endl;

        std::map<size_t,int> hashTableOfPoints;
        for(TColStd_MapIteratorOfPackedMapOfInteger it(outputSurfaceMeshDS->GetAllNodes()); it.More(); it.Next())
        {
            int globalNodeID = it.Key();
            int NbNodes;
            MeshVS_EntityType aType;
            double buf[3];
            TColStd_Array1OfReal coords(*buf,3);
            outputSurfaceMeshDS->GetGeom(globalNodeID,false,coords,NbNodes,aType);
            size_t pointHash = 0;
            for(int n=1; n<=3; n++) hash_c<double>(pointHash,coords(n));
            hashTableOfPoints.insert(std::make_pair(pointHash,globalNodeID));
        }

        cout<<" hash table of the surface mesh generated"<<endl;
        cout<<"********************************************************************"<<endl;

        cout<<"********************************************************************"<<endl;
        cout<<" generating vector of points with tolerance"<<endl;

        const std::vector<mesh::tolerantPoint> &vecTolerantPoints = occHandle(Ng_MeshVS_DataSource2D)::DownCast(outputSurfaceMeshDS)->buildTolerantPoints(1e-6);
        std::vector<int> vecGlobalNodeIDs;
        for(TColStd_MapIteratorOfPackedMapOfInteger it(outputSurfaceMeshDS->GetAllNodes()); it.More(); it.Next())
            vecGlobalNodeIDs.push_back(it.Key());

        cout<<" table generated"<<endl;
        cout<<"********************************************************************"<<endl;

        //! ------------------------------------------------------------
        //! use the surface mesh for assigning a globalElementID number
        //! to each point of the current triangle
        //! ------------------------------------------------------------
        std::vector<meshElement2D> vecMeshElement2D;                //! unmapped triangles
        std::vector<std::vector<int>> vecTriangles;                 //! unmapped triangles defined through globalNodeIDs
        for(std::vector<std::vector<double>>::iterator it = vecUnassociatedElements.begin(); it!=vecUnassociatedElements.end(); it++)
        {
            const std::vector<double> &triangle = *it;

            cout<<"******************************************************************************"<<endl;
            cout<<" this is one of the triangles which cannot be associated to any geometry face"<<endl;
            cout<<" ("<<triangle[0]<<", "<<triangle[1]<<", "<<triangle[2]<<")"<<endl;
            cout<<" ("<<triangle[3]<<", "<<triangle[4]<<", "<<triangle[5]<<")"<<endl;
            cout<<" ("<<triangle[6]<<", "<<triangle[7]<<", "<<triangle[8]<<")"<<endl;
            cout<<"******************************************************************************"<<endl;

            meshElement2D curMeshElement2D;
            std::vector<int> curTriangleIDs;
            for(int n=0; n<3; n++)
            {
                int s = 3*n;
                size_t pointHash = 0;
                hash_c<double>(pointHash,triangle[s]);
                hash_c<double>(pointHash,triangle[s+1]);
                hash_c<double>(pointHash,triangle[s+2]);
                if(hashTableOfPoints.count(pointHash)!=0)
                {
                    int globalNodeID = hashTableOfPoints.at(pointHash);
                    cout<<"____point found! globalNodeID: "<<globalNodeID<<"____"<<endl;
                    curTriangleIDs.push_back(globalNodeID);
                    curMeshElement2D.nodeIDs<<globalNodeID;
                }
                else
                {
                    cout<<"____point not found! Trying to use geometric tolerance: ";

                    //! ----------------------------------------
                    //! trying to find the node using proximity
                    //! ----------------------------------------
                    mesh::tolerantPoint thePoint(triangle[s],triangle[s+1],triangle[s+2],1e-6);
                    std::vector<mesh::tolerantPoint>::const_iterator it1 = std::find(vecTolerantPoints.cbegin(),vecTolerantPoints.cend(),thePoint);
                    if(it1!=vecTolerantPoints.cend())
                    {
                        int indexOf = std::distance(vecTolerantPoints.cbegin(),it1);
                        int globalNodeID = vecGlobalNodeIDs[indexOf];

                        //retrievedByProximity++;
                        cout<<" found!____"<<endl;
                    }
                    else
                    {
                        cout<<" not found____"<<endl;
                    }
                }
            }

            //! to be completed: if the points of an unassociated triangle cannot
            //! be recovedere using hash numbers or using proximity, the triangle
            //! should not be stored
            //!
            vecTriangles.push_back(curTriangleIDs);
            vecMeshElement2D.push_back(curMeshElement2D);
        }

        //! ----------------------------------------------------------------------
        //! overall surface mesh: build the map <mesh element, global element ID>
        //! ----------------------------------------------------------------------
        std::map<meshElement2D,int> surfaceELementToGlobalElementID;
        for(TColStd_MapIteratorOfPackedMapOfInteger it(outputSurfaceMeshDS->GetAllElements()); it.More(); it.Next())
        {
            int curGlobalElementID = it.Key();
            int buf[3], NbNodes;
            TColStd_Array1OfInteger nodeIDs(*buf,1,3);
            outputSurfaceMeshDS->GetNodesByElement(curGlobalElementID,nodeIDs,NbNodes);
            meshElement2D aMeshElement2D;
            aMeshElement2D.ID = curGlobalElementID;
            for(int n=1; n<=3; n++) aMeshElement2D.nodeIDs<<nodeIDs(n);
            surfaceELementToGlobalElementID.insert(std::make_pair(aMeshElement2D,curGlobalElementID));
        }

        //! ----------------------------------------------------------
        //! search the pending triangle into the overall surface mesh
        //! ----------------------------------------------------------
        cout<<"********************************************************************"<<endl;
        cout<<" searching the pending triangles into the overall surface mesh"<<endl;

        std::vector<meshElementByCoords> vecUnassignedMeshElementByCoords;                //! unassociated triangles
        for(int index = 0; index<vecMeshElement2D.size(); index++)
        {
            const meshElement2D &unassignedTriangle = vecMeshElement2D[index];
            std::map<meshElement2D,int>::iterator itm = surfaceELementToGlobalElementID.find(unassignedTriangle);
            if(itm != surfaceELementToGlobalElementID.end())
            {
                cout<<"____found unassigned triangle into the overall surface mesh_____"<<endl;
                int globalElementID = itm->second;
                meshElementByCoords aMeshElement;
                aMeshElement.ID = globalElementID;
                int NbPoints = unassignedTriangle.nodeIDs.length();
                aMeshElement.type = TRIG;
                for(int n=0; n<NbPoints; n++)
                {
                    int curGlobalNodeID = unassignedTriangle.nodeIDs[n];
                    int s = 3*n;
                    const std::vector<double> &curUnassociatedElement = vecUnassociatedElements[index];
                    mesh::meshPoint aMeshPoint(curUnassociatedElement[s], curUnassociatedElement[s+1], curUnassociatedElement[s+2], curGlobalNodeID);
                    aMeshElement.pointList<<aMeshPoint;
                }
                vecUnassignedMeshElementByCoords.push_back(aMeshElement);
            }
        }
        cout<<" search finished"<<endl;
        cout<<"********************************************************************"<<endl;

        //! ---------------------------
        //! map <segment, face number>
        //! ---------------------------
        cout<<"********************************************************************"<<endl;
        cout<<" scanning the face mesh datasources"<<endl;
        cout<<" building segment to face number map"<<endl;

        std::map<mesh::meshSegment,std::vector<int>> segmentFaceNrMap;
        for(int faceNr = 1; faceNr<= NbFaces; faceNr++)
        {
            occHandle(MeshVS_DataSource) aMeshDS = myMDB->ArrayOfMeshDSOnFaces.getValue(bodyIndex,faceNr);
            if(aMeshDS.IsNull()) continue;
            occHandle(Ng_MeshVS_DataSourceFace) aFaceMeshDS = occHandle(Ng_MeshVS_DataSourceFace)::DownCast(aMeshDS);

            if(aFaceMeshDS->mySegmentToElement.isEmpty()) aFaceMeshDS->computeFreeMeshSegments();
            const QMap<mesh::meshSegment,QList<int>> &segmentsToElement = aFaceMeshDS->mySegmentToElement;
            for(QMap<mesh::meshSegment,QList<int>>::const_iterator it_ = segmentsToElement.cbegin(); it_!=segmentsToElement.cend(); it_++)
            {
                mesh::meshSegment aSegment = it_.key();
                std::map<mesh::meshSegment,std::vector<int>>::iterator it__ = segmentFaceNrMap.find(aSegment);
                if(it__==segmentFaceNrMap.end())
                {
                    std::vector<int> v { faceNr };
                    segmentFaceNrMap.insert(std::make_pair(aSegment,v));
                }
                else it__->second.push_back(faceNr);
            }
        }

        cout<<" segment to face number map built"<<endl;
        cout<<"********************************************************************"<<endl;

        //! --------------------------------
        //! scan the unassociated triangles
        //! --------------------------------
        cout<<"********************************************************************"<<endl;
        cout<<" trying to reassign pending triangles"<<endl;

        int NbReassigned = 0;
        std::map<int,std::vector<meshElementByCoords>> faceNrToMissingTriangles;
        std::vector<std::pair<int,meshElementByCoords>> missingTrianglesToFaceNr;
        for(std::vector<meshElementByCoords>::iterator it = vecUnassignedMeshElementByCoords.begin(); it!= vecUnassignedMeshElementByCoords.end(); it++)
        {
            const meshElementByCoords &curElement = *it;

            //! ------------------------------------------
            //! find the segments of the current triangle
            //! ------------------------------------------
            bool canbereassigned = false;
            int faceNr = -1;
            int NbNodes = curElement.pointList.length();

            std::vector<mesh::meshSegment> vecSegmentsOfElement;    // segments of the unassigned element

            for(int i=1; i<=NbNodes; i++)
            {
                mesh::meshSegment aMeshSegment;
                int firstIndex = (i-1)%NbNodes;
                int secondIndex = i%NbNodes;
                aMeshSegment.nodeIDs<<curElement.pointList[firstIndex].ID;
                aMeshSegment.nodeIDs<<curElement.pointList[secondIndex].ID;
                aMeshSegment.sort();

                //! store the segments of the unassigned element
                vecSegmentsOfElement.push_back(aMeshSegment);

                if(segmentFaceNrMap.count(aMeshSegment)!=0)
                {
                    NbReassigned++;
                    faceNr = segmentFaceNrMap.at(aMeshSegment).at(0);

                    cout<<" the triangle: (";
                    for(int h=0; h<NbNodes-1; h++) cout<<curElement.pointList[h].ID<<" ";
                    cout<<curElement.pointList[NbNodes-1].ID<<") "<<" can be assigned to face "<<faceNr<<"____"<<endl;
                    if(segmentFaceNrMap.at(aMeshSegment).size()>1) cout<<" (actually more than one face) "<<endl;

                    missingTrianglesToFaceNr.push_back(std::make_pair(faceNr,curElement));   // alternative                    
                    canbereassigned = true;                    

                    //! ---------------------------------------------------------------
                    //! the element has been recognized belonging to the face "faceNr"
                    //! thankgs to the current segment. Remove if from the vector of
                    //! segments
                    //! ---------------------------------------------------------------
                    vecSegmentsOfElement.pop_back();

                    //! -------------------------------------------------------------------
                    //! since this triangle can be reassigned to the current face "faceNr"
                    //! thanks to a segment link, then the other two segments should be
                    //! added to the map "segmentFaceNrMap" used for the search
                    //! -------------------------------------------------------------------
                    for(int n=0; n<vecSegmentsOfElement.size(); n++)
                    {
                        const mesh::meshSegment &as = vecSegmentsOfElement[n];
                        std::map<mesh::meshSegment,std::vector<int>>::iterator its = segmentFaceNrMap.find(as);
                        if(its == segmentFaceNrMap.end()) segmentFaceNrMap.insert(std::make_pair(as,std::vector<int> {faceNr} ));
                        else its->second.push_back(faceNr);
                    }
                    break;
                }
            }
            if(canbereassigned)
            {
                std::map<int,std::vector<meshElementByCoords>>::iterator its = faceNrToMissingTriangles.find(faceNr);
                if(its == faceNrToMissingTriangles.end())
                {
                    std::vector<meshElementByCoords> v { curElement };
                    faceNrToMissingTriangles.insert(std::make_pair(faceNr,v));
                    cout<<" inserting"<<endl;
                }
                else
                {
                    its->second.push_back(curElement);
                    cout<<" inserting multiple "<<endl;
                }
            }
        }

        cout<<" # "<<NbReassigned<<" triangles reassigned "<<endl;
        cout<<"********************************************************************"<<endl;

        cout<<"********************************************************************"<<endl;
        cout<<" start modifying the face mesh data sources"<<endl;

        for(std::vector<std::pair<int,meshElementByCoords>>::iterator itt = missingTrianglesToFaceNr.begin(); itt!=missingTrianglesToFaceNr.end(); itt++)
        {
            int curFaceNr = itt->first;
            cout<<"____faceNr: "<<curFaceNr<<"____"<<endl;

            const meshElementByCoords &anElement = itt->second;

            occHandle(MeshVS_DataSource) aMeshDS = myMDB->ArrayOfMeshDSOnFaces.getValue(bodyIndex,curFaceNr);
            occHandle(Ng_MeshVS_DataSourceFace) curFaceMeshDS = occHandle(Ng_MeshVS_DataSourceFace)::DownCast(aMeshDS);
            curFaceMeshDS->addElement(anElement);
            myMDB->ArrayOfMeshDSOnFaces.setValue(bodyIndex, curFaceNr, curFaceMeshDS);
        }

        cout<<" the face mesh data sources have been modified"<<endl;
        cout<<"********************************************************************"<<endl;
    }

    if(isVolume)
    {
        //! -----------------------------
        //! convert into mesh::meshPoint
        //! -----------------------------
        std::vector<mesh::meshPoint> vecVolumeMeshPoints;
        for(int n = 0; n<volumeMeshPoints.size(); n++)
        {
            const Ng_meshPoint &nmp = volumeMeshPoints.at(n);
            mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
            vecVolumeMeshPoints.push_back(aMeshPoint);
        }
        //! -------------------------------
        //! convert into mesh::meshElement
        //! -------------------------------
        std::vector<mesh::meshElement> vecVolumeMeshElements;
        for(int n=0; n<volumeMeshElements.size(); n++)
        {
            const Ng_volumeMeshElement &nve = volumeMeshElements.at(n);
            mesh::meshElement aVolumeMeshElement;
            int NbNodes = 0;

            switch(nve.type)
            {
            case NG_TET:
            {
                NbNodes = 4;
                aVolumeMeshElement.type = TET;
            }
                break;
            case NG_TET10:
            {
                NbNodes = 10;
                aVolumeMeshElement.type = TET10;
                //! currently the netgen mesher is used only for
                //! generating first order grids
            }
                break;
            case NG_PYRAMID:
            {
                NbNodes = 5;
                aVolumeMeshElement.type = PYRAM;
                //! currently this element is not generated by netgen
            }
                break;
            case NG_PRISM:
            {
                NbNodes = 6;
                aVolumeMeshElement.type = PRISM;
                //! currently this element is not generated by netgen
            }
                break;
            }
            //! ----------------------
            //! add the element nodes
            //! ----------------------
            for(int k=0; k<NbNodes; k++)
            {
                int nodeID = nve.nodeIDs.at(k);
                aVolumeMeshElement.theNodeIDs.push_back(nodeID);
            }
            aVolumeMeshElement.ID = n+1;
            vecVolumeMeshElements.push_back(aVolumeMeshElement);
        }

        outputVolumeMeshDS = new Ng_MeshVS_DataSource3D(vecVolumeMeshElements, vecVolumeMeshPoints);

        if(outputVolumeMeshDS.IsNull())
        {
            mr.isDone = true;
            mr.message = "error in generating the volume mesh data source";
            return mr;
        }
        mr.isDone = true;
        mr.message = QString("The mesh has been successfully generated");
        return mr;
    }

    mr.isDone = true;
    mr.message = QString("The mesh has been successfully generated");

    //! -----------------------------
    //! reset the progress indicator
    //! -----------------------------
    progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",
                                       QProgressEvent_Reset,0,9999,0,"");
    QApplication::postEvent(myProgressIndicator,progressEvent);
    QApplication::processEvents();

    return mr;
}

//! --------------------------------------
//! function: initNetgenMeshingParameters
//! details:
//! --------------------------------------
Ng_Meshing_Parameters NettgenTool2::initNetgenMeshingParameters()
{
    Ng_Meshing_Parameters mp;
    mp.uselocalh = 1;                   // Enable/Disable usage of local mesh size modifiers
    mp.maxh = 100;                       // Maximum allowed mesh size
    mp.minh= 0.1;                       // Minimum allowed ->global<- mesh size allowed
    mp.fineness = 0.5;                  // Mesh density: 0...1 (0 => coarse; 1 => fine)
    mp.grading = 0.3;                   // Mesh grading: 0...1 (0 => uniform mesh; 1 => aggressive local grading)
    mp.elementsperedge=4;               // Number of elements to generate per edge
    mp.elementspercurve=2;              // Elements to generate per curvature radius
    mp.closeedgeenable=0;               // Enable/Disable mesh refinement at close edges
    mp.closeedgefact=0;                 // Factor to use for refinement at close edges (larger => finer)
    mp.minedgelenenable=0;              // Enable/Disable user defined minimum edge length for edge subdivision
    mp.minedgelen=1e-4;                 // Minimum edge length to use while subdividing the edges (default = 1e-4)
    mp.second_order=0;                  // Generate second-order surface and volume elements
    mp.quad_dominated=0;                // Creates a Quad-dominated mesh
    mp.optsurfmeshenable=1;             // Enable/Disable automatic surface mesh optimization
    mp.optvolmeshenable=1;              // Enable/Disable automatic volume mesh optimization
    mp.optsteps_2d=2;                   // Number of optimize steps to use for 2-D mesh optimization
    mp.optsteps_3d=2;                   // Number of optimize steps to use for 3-D mesh optimization
    mp.check_overlapping_boundary = 1;
    mp.check_overlap = 1;
    mp.invert_tets = 0;
    mp.invert_trigs = 0;

    return mp;
}

//! --------------------------------------------------------------------
//! function: sampleGeometry
//! details:  a set of points is sampled on a sub-geometry and returned
//! --------------------------------------------------------------------
void NettgenTool2::sampleGeometry(const TopoDS_Shape &aShape,
                                  const QVariant &parametersForSampling,
                                  std::vector<std::vector<double>> &sampledPoints)
{
    cout<<"NettgenTool2::sampleGeometry()->____function called____"<<endl;
    if(aShape.IsNull())
    {
        cout<<"NettgenTool2::sampleGeometry()->____the input shape is null____"<<endl;
        return;
    }

    //! ------------------------------
    //! the bounding box of the shape
    //! ------------------------------
    Bnd_Box BB;
    BRepBndLib::Add(aShape, BB);
    double xmin, ymin, zmin, xmax, ymax, zmax;
    BB.Get(xmin,ymin,zmin,xmax,ymax,zmax);

    switch(aShape.ShapeType())
    {
    case TopAbs_FACE:
    {
        std::vector<double> samplingParameters = parametersForSampling.value<std::vector<double>>();
        double elementSizeOnFace = samplingParameters.at(0);
        cout<<"NettgenTool2::sampleGeometry()->____"<<elementSizeOnFace<<" (unused)____"<<endl,
        Q_UNUSED(elementSizeOnFace);

        //! -----------------------------------------------
        //! a new bounding box for the face - a bit larger
        //! -----------------------------------------------
        double dx = (xmax-xmin)*0.025;
        double dy = (ymax-ymin)*0.025;
        double dz = (zmax-zmin)*0.025;

        double xmin_bb = xmin - dx; double xmax_bb = xmax + dx;
        double ymin_bb = ymin - dy; double ymax_bb = ymax + dy;
        double zmin_bb = zmin - dz; double zmax_bb = zmax + dz;

        //! ---------
        //! the face
        //! ---------
        //cout<<"NettgenTool2::sampleGeometry()->____start sampling a face____"<<endl;
        const TopoDS_Face &aFace = TopoDS::Face(aShape);

        //! --------------------
        //! surface of the face
        //! --------------------
        BRepAdaptor_Surface adaptor(aFace,true);
        const GeomAdaptor_Surface &s_adaptor = adaptor.Surface();
        occHandle(Geom_Surface) CurGeomSurface = s_adaptor.Surface();

        //! --------------------------------------------------
        //! retrieve the u,v bounds
        //! enclose the into a rectangle and perform sampling
        //! for the moment a 100x100 grid is used ...
        //! --------------------------------------------------
        double umin,umax,vmin,vmax;
        BRepTools::UVBounds(aFace,umin,umax,vmin,vmax);
        double Lu = umax-umin;
        double Lv = vmax-vmin;
        double du = Lu/100;
        double dv = Lv/100;

        //FILE *fp = fopen("D:\\sampled_face.txt","w");
        for(double ucur = umin; ucur<=umax; ucur += du)
        {
            for(double vcur = vmin; vcur<=vmax; vcur +=dv)
            {
                const gp_Pnt &curPoint = CurGeomSurface->Value(ucur,vcur);
                double x = curPoint.X();
                double y = curPoint.Y();
                double z = curPoint.Z();
                //fprintf(fp,"%lf\t%lf\t%lf\n",x,y,z);

                //! --------------------------------------------------
                //! check if the point is whithin the BB of the shape
                //! --------------------------------------------------
                if((x>=xmin_bb && x<=xmax_bb) && (y>=ymin_bb && y<=ymax_bb) && (z>=zmin_bb && z<=zmax_bb))
                {
                    std::vector<double> P{x,y,z};
                    sampledPoints.push_back(P);
                }
            }
        }
        //fclose(fp);
    }
        break;

    case TopAbs_EDGE:
    {
        //! ------------------------------------------------
        //! parameter for the edge sizing
        //! at the moment only one parameter in the vector:
        //! the element size on the edge (length)
        //! ------------------------------------------------
        std::vector<double> samplingParameters = parametersForSampling.value<std::vector<double>>();
        double size = samplingParameters.at(0);

        //FILE *fp = fopen("D:\\sampled_edge.txt","w");

        //! ---------
        //! the edge
        //! ---------
        //cout<<"NettgenTool2::sampleGeometry()->____start sampling an edge____"<<endl;
        const TopoDS_Edge &anEdge = TopoDS::Edge(aShape);
        if(BRep_Tool::Degenerated(anEdge)) break;
        BRepAdaptor_Curve BRepAdaptor(anEdge);
        GeomAdaptor_Curve curve = BRepAdaptor.Curve();

        //! -------------------
        //! length of the edge
        //! -------------------
        CPnts_AbscissaPoint CP;
        CP.Init(curve);
        double s_old = BRepAdaptor.FirstParameter();
        const gp_Pnt &P_onEdge = BRepAdaptor.Value(s_old);
        double x = P_onEdge.X();
        double y = P_onEdge.Y();
        double z = P_onEdge.Z();
        std::vector<double> P{x,y,z};
        sampledPoints.push_back(P);

        double Lcurrent = 0;
        double L = CP.Length(curve,1e-2);

        for(double s=s_old-size;Lcurrent<=L+size;)
        {
            CP.Perform(size,s,1e-2);

            const gp_Pnt &P1_onEdge = BRepAdaptor.Value(s);
            x = P1_onEdge.X();
            y = P1_onEdge.Y();
            z = P1_onEdge.Z();
            std::vector<double> P1{x,y,z};
            //fprintf(fp,"%lf\t%lf\t%lf\n",x,y,z);
            sampledPoints.push_back(P1);

            s_old=s;
            s=CP.Parameter();
            Lcurrent += fabs(s-s_old);
        }
        //fclose(fp);
    }
        break;

    case TopAbs_VERTEX:
    {
        //! ---------------------------------------------
        //! parameter for the mesh sizing at the vertex.
        //! one parameters in the vector: pinball radius
        //! ---------------------------------------------
        std::vector<double> samplingParameters = parametersForSampling.value<std::vector<double>>();

        //! radial, theta, phi divisions
        const double PI = 3.141592654;
        const int radialDiv = 10;
        const int thetaDiv = 20;
        const int phiDiv = 10;

        //! pinball
        double R = samplingParameters.at(0);
        double dr = R/radialDiv;

        //! coordinates of the selected vertex
        const gp_Pnt &V = BRep_Tool::Pnt(TopoDS::Vertex(aShape));

        double deltaTheta = 2*PI/thetaDiv;
        double deltaPhi = PI/phiDiv;
        for(double theta =0; theta<2*PI; theta +=deltaTheta)
        {
            for(double phi = -PI/2; phi<=PI/2; phi +=deltaPhi)
            {
                for(double r = dr; r<=R; r+=dr)
                {
                    double x = V.X()+r*cos(phi)*cos(theta);
                    double y = V.Y()+r*cos(phi)*sin(theta);
                    double z = V.Z()+r*sin(phi);
                    std::vector<double> P1{x,y,z};
                    sampledPoints.push_back(P1);
                }
            }
        }
    }
        break;
    }
}

//! ------------------------
//! function: checkDataBase
//! details:
//! ------------------------
bool NettgenTool2::checkDataBase()
{
    cout<<"\\----------------------------------------------------\\"<<endl;
    cout<<"\\ data base check                                    \\"<<endl;
    cout<<"\\ - number of bodies: "<<myMDB->bodyMap.size()<<endl;
    for(QMap<int,TopoDS_Shape>::iterator it=myMDB->bodyMap.begin(); it!=myMDB->bodyMap.end(); ++it)
    {
        int bodyIndex = it.key();
        cout<<"\\ - body nr: "<<bodyIndex<<" type: "<<it.value().ShapeType()<<endl;
        cout<<"\\ - name: "<<myMDB->MapOfBodyNames.value(bodyIndex).toStdString()<<endl;

        //! ------------
        //! check faces
        //! ------------
        int NbFaces = myMDB->MapOfBodyTopologyMap.value(bodyIndex).faceMap.Extent();
        if(myMDB->MapOfBodyTopologyMap.value(bodyIndex).faceMap.IsEmpty()) cout<<" - the face map is empty! "<<endl;
        cout<<"\\ - number of faces: "<<NbFaces<<endl;
        for(int n=1; n<=NbFaces; n++)
        {
            const TopoDS_Face &curFace = TopoDS::Face(myMDB->MapOfBodyTopologyMap.value(bodyIndex).faceMap.FindKey(n));
            cout<<"\\ -- face nr: "<<n<<" is: "<<(curFace.IsNull()? "not valid":"valid")<<endl;
        }
        //! ------------
        //! check edges
        //! ------------
        int NbEdges = myMDB->MapOfBodyTopologyMap.value(bodyIndex).edgeMap.Extent();
        if(myMDB->MapOfBodyTopologyMap.value(bodyIndex).edgeMap.IsEmpty()) cout<<" - the edge map is empty! "<<endl;
        cout<<"\\ - number of edges: "<<NbFaces<<endl;
        for(int n=1; n<=NbEdges; n++)
        {
            const TopoDS_Edge &curEdge = TopoDS::Edge(myMDB->MapOfBodyTopologyMap.value(bodyIndex).edgeMap.FindKey(n));
            cout<<"\\ -- edge nr: "<<n<<" is: "<<(curEdge.IsNull()? "not valid":"valid")<<endl;
        }

        cout<<"\\ - number of vertices: "<<myMDB->MapOfBodyTopologyMap.value(bodyIndex).vertexMap.Extent()<<endl;
    }
    cout<<"\\----------------------------------------------------\\"<<endl;
    return true;
}

//! -------------------------------
//! function: setProgressIndicator
//! details:
//! -------------------------------
void NettgenTool2::setProgressIndicator(QProgressIndicator *aProgressIndicator)
{
    if(aProgressIndicator!=Q_NULLPTR)
    {
        myProgressIndicator = aProgressIndicator;
        disconnect(this,SIGNAL(requestEnableStop()),myProgressIndicator,SLOT(enableStop()));
        disconnect(this,SIGNAL(requestDisableStop()),myProgressIndicator,SLOT(disableStop()));
        connect(this,SIGNAL(requestEnableStop()),myProgressIndicator,SLOT(enableStop()));
        connect(this,SIGNAL(requestDisableStop()),myProgressIndicator,SLOT(disableStop()));
        cout<<"NettgenTool2::setProgressIndicator()->____"<<myProgressIndicator->getText().toStdString()<<"____"<<endl;
    }
}

//! -----------------------------------
//! function: performBrep
//! details:  works on an OCC geometry
//! -----------------------------------
userMessage NettgenTool2::performBrep(int bodyIndex,
                                     bool isVolume,
                                     occHandle(MeshVS_DataSource) &outputSurfaceMeshDS,
                                     occHandle(MeshVS_DataSource) &outputVolumeMeshDS)
{
    userMessage mr;
    mr.isDone = false;
    mr.message ="";

    //! ----------------------
    //! send a progress event
    //! ----------------------
    QProgressEvent *progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",QProgressEvent_Init,0,100,0,"Netgen meshing");
    QApplication::postEvent(myProgressIndicator,progressEvent);

    //! ----------------------------
    //! init the meshing parameters
    //! ----------------------------
    Ng_Meshing_Parameters mp = initNetgenMeshingParameters();

    //! -----------------------------------------------------------
    //! the global meshing parameters read from the mesh data base
    //! -----------------------------------------------------------
    mp.grading = myMDB->ArrayOfGradingValue.value(bodyIndex);
    mp.minh = myMDB->ArrayOfMinBodyElementSize.value(bodyIndex);
    mp.maxh = myMDB->ArrayOfMaxBodyElementSize.value(bodyIndex);

    cout<<"\\----------------------------------------------------------------------\\"<<endl;
    cout<<"\\- meshing parameters from interface                                   \\"<<endl;
    cout<<"\\- grading = "<<mp.grading<<endl;
    cout<<"\\- minh = "<<mp.minh<<endl;
    cout<<"\\- maxh = "<<mp.maxh<<endl;

    //! -------------------------------------------------------------------------
    //! workaround - all the faces in the geometry data base are incredibly null
    //! and so all the other sub-geometries
    //! -------------------------------------------------------------------------
    const TopoDS_Shape &curBody = myMDB->bodyMap.value(bodyIndex);
    TopTools_IndexedMapOfShape faceMap;
    TopTools_IndexedMapOfShape edgeMap;
    TopTools_IndexedMapOfShape vertexMap;
    TopExp::MapShapes(curBody,TopAbs_FACE,faceMap);
    TopExp::MapShapes(curBody,TopAbs_EDGE,edgeMap);
    TopExp::MapShapes(curBody,TopAbs_VERTEX,vertexMap);

    //! ----------------------------------------------------------------------------
    //! a "local" (i.e. defined on a sub-geometry) mesh control is defined through
    //! a vector of sampled point on that subgeometry and by the element size value
    //! ----------------------------------------------------------------------------
    std::vector<std::pair<std::vector<std::vector<double>>,double>> meshControls;
    int NbFaces = myMDB->MapOfBodyTopologyMap.value(bodyIndex).faceMap.Extent();
    for(int faceNr = 1; faceNr<=NbFaces; faceNr++)
    {
        bool isMeshControlOnFace = myMDB->MapOfIsFaceModified.getValue(bodyIndex,faceNr);
        if(isMeshControlOnFace)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- face mesh control on face: "<<faceNr<<" is: "<<(isMeshControlOnFace? "ON":"OFF")<<" => ";
            double maxElementSize = myMDB->MapOfElementSizeOnFace.getValue(bodyIndex,faceNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;

            //! ------------------------------------------------------
            //! parameters for sampling - a vector of double
            //! here only one value, i.e. the face sizing on the face
            //! ------------------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(maxElementSize);
            parametersForSampling.setValue(parameters);

            const TopoDS_Shape &curFace = faceMap.FindKey(faceNr);
            std::vector<std::vector<double>> sampledPoints;
            this->sampleGeometry(curFace,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
        }
    }

    int NbEdges = myMDB->MapOfBodyTopologyMap.value(bodyIndex).edgeMap.Extent();
    for(int edgeNr = 1; edgeNr<=NbEdges; edgeNr++)
    {
        bool isMeshControlOnEdge = myMDB->MapOfIsEdgeModified.getValue(bodyIndex,edgeNr);
        if(isMeshControlOnEdge)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- edge mesh control on edge: "<<edgeNr<<" is: "<<(isMeshControlOnEdge? "ON":"OFF")<<" => ";
            double maxElementSize = myMDB->MapOfElementSizeOnEdge.getValue(bodyIndex,edgeNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;
            const TopoDS_Shape &curEdge = edgeMap.FindKey(edgeNr);
            std::vector<std::vector<double>> sampledPoints;

            //! ---------------------------------------------
            //! parameters for sampling - a vector of double
            //! here only one value, i.e. the edge sizing
            //! ---------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(maxElementSize);
            parametersForSampling.setValue(parameters);

            this->sampleGeometry(curEdge,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
        }
    }

    int NbVertices = myMDB->MapOfBodyTopologyMap.value(bodyIndex).vertexMap.Extent();
    for(int vertexNr = 1; vertexNr<=NbVertices; vertexNr++)
    {
        bool isMeshControlOnVertex = myMDB->MapOfIsVertexModified.getValue(bodyIndex,vertexNr);
        if(isMeshControlOnVertex)
        {
            std::pair<std::vector<std::vector<double>>,double> aLocalMeshControl;
            //cout<<"\\- vertex mesh control on vertex: "<<vertexNr<<" is: "<<(isMeshControlOnVertex? "ON":"OFF")<<" => ";

            double maxElementSize = myMDB->MapOfElementSizeOnVertex.getValue(bodyIndex,vertexNr);
            double pinball = myMDB->MapOfVertexPinball.getValue(bodyIndex,vertexNr);
            //cout<<"____value: "<<maxElementSize<<"____"<<endl;
            //cout<<"____pinball: "<<pinball<<"____"<<endl;

            //! ---------------------------------------------
            //! parameters for sampling - a vector of double
            //! here pinball value
            //! ---------------------------------------------
            QVariant parametersForSampling;
            std::vector<double> parameters;
            parameters.push_back(pinball);
            parametersForSampling.setValue(parameters);

            const TopoDS_Shape &curVertex = vertexMap.FindKey(vertexNr);
            std::vector<std::vector<double>> sampledPoints;
            this->sampleGeometry(curVertex,parametersForSampling,sampledPoints);
            aLocalMeshControl.first = sampledPoints;
            aLocalMeshControl.second = maxElementSize;
            meshControls.push_back(aLocalMeshControl);
         }
    }

    cout<<"\\----------------------------------------------------------------------\\"<<endl;

    void *localMeshSizingControls = (void*)(&meshControls);

    //! --------------------
    //! netgen/nglib inputs
    //! --------------------
    void *validFaceTags;// = (void*)(&faceTags); // unused

    bool isDone = false;

    //! ------------------
    //! the shape to mesh
    //! ------------------
    void *shape =(void*)(&curBody);

    //! -----------------------------------
    //! the meshing results - surface mesh
    //! -----------------------------------
    std::vector<Ng_meshPoint> surfaceMeshPoints;
    void *surfaceMeshPointsP = (void*)(&surfaceMeshPoints);
    std::vector<Ng_surfaceMeshElement> surfaceMeshElements;
    void *surfaceMeshElementsP = (void*)(&surfaceMeshElements);

    //! ----------------------------------
    //! the meshing results - volume mesh
    //! ----------------------------------
    std::vector<Ng_meshPoint> volumeMeshPoints;
    void *volumeMeshPointsP = (void*)(&volumeMeshPoints);
    std::vector<Ng_volumeMeshElement> volumeMeshElements;
    void *volumeMeshElementsP = (void*)(&volumeMeshElements);

    //! --------------------------------
    //! the meshing results - face mesh
    //! --------------------------------
    std::vector<std::pair<std::vector<Ng_meshPoint>,std::vector<Ng_surfaceMeshElement>>> faceMeshes;
    void *faceMeshesP = (void*)(&faceMeshes);

    //! ------------------------------------------------------------
    //! the main call for generating the surface or the volume mesh
    //! ------------------------------------------------------------
#ifndef HANDLE_NGLIB_SYSTEM_EXCEPTIONS
    isDone = Ng_OCC_buildMesh(isVolume,
                              shape,
                              validFaceTags,
                              &mp,
                              localMeshSizingControls,
                              surfaceMeshPointsP,
                              surfaceMeshElementsP,
                              volumeMeshPointsP,
                              volumeMeshElementsP,
                              faceMeshesP);
#endif

#ifdef HANDLE_NGLIB_SYSTEM_EXCEPTIONS
    BRepMeshing_InOutParameters m;

    //! -------
    //! inputs
    //! -------
    m.isVolume = isVolume;
    m.shape = shape;
    m.validFaceTags = validFaceTags;
    m.mp = &mp;
    m.localMeshSizingControls = localMeshSizingControls;
    //! --------
    //! outputs
    //! --------
    m.surfaceMeshPointsP = surfaceMeshPointsP;
    m.surfaceMeshElementsP = surfaceMeshElementsP;
    m.volumeMeshPointsP = volumeMeshPointsP;
    m.volumeMeshElementsP = volumeMeshElementsP;
    m.faceMeshesP = faceMeshesP;

    try
    {
        emit requestStartingNetgenEnquireTimer();
        _set_se_translator(trans_func_N);
        isDone = this->SystemErrorFunction_1(m);
    }
    catch(SE_Exception)
    {
        cout<<"NettgenTool2::perform()->____a netgen system error has been captured____"<<endl;
        emit requestStoppingNetgenEnquireTimer();
        mr.isDone = false;
        mr.message = QString("Netgen BRep meshing failure");
        return mr;
    }
#endif

    cout<<"NetgenTool2::performBrep()->____EXITING NETGEN: "<<isDone<<"____"<<endl;

    if(!isDone)
    {
        mr.isDone = false;
        mr.message = QString("Netgen cannot generate the surface mesh");
        return mr;
    }

    if(isVolume)
    {
        cout<<"NettgenTool2::performBrep()->____number of volume mesh points: "<<volumeMeshPoints.size()<<"____"<<endl;
        cout<<"NettgenTool2::performBrep()->____number of volume mesh elements: "<<volumeMeshElements.size()<<"____"<<endl;
    }

    //! -----------------------------
    //! convert into mesh::meshPoint
    //! -----------------------------
    std::vector<mesh::meshPoint> vecSurfaceMeshPoints;
    for(int n = 0; n<surfaceMeshPoints.size(); n++)
    {
        const Ng_meshPoint &nmp = surfaceMeshPoints.at(n);
        mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
        vecSurfaceMeshPoints.push_back(aMeshPoint);
    }

    //! -------------------------------
    //! convert into mesh::meshElement
    //! -------------------------------
    std::vector<mesh::meshElement> vecSurfaceMeshElements;
    for(int n=0; n<surfaceMeshElements.size(); n++)
    {
        const Ng_surfaceMeshElement &nme = surfaceMeshElements.at(n);
        mesh::meshElement aSurfaceMeshElement;
        int NbNodes = 0;

        switch(nme.type)
        {
        case NG_TRIG:
        {
            NbNodes = 3;
            aSurfaceMeshElement.type = TRIG;
        }
            break;
        case NG_TRIG6:
        {
            NbNodes = 6;
            aSurfaceMeshElement.type = TRIG6;
        }
            break;
        case NG_QUAD:
        {
            NbNodes = 4;
            aSurfaceMeshElement.type = QUAD;
        }
            break;
        case NG_QUAD8:
        {
            NbNodes = 8;
            aSurfaceMeshElement.type = QUAD8;
        }
            break;
        }
        //! ----------------------
        //! add the element nodes
        //! ----------------------
        for(int k=0; k<NbNodes; k++)
        {
            int nodeID = nme.nodeIDs.at(k);
            aSurfaceMeshElement.theNodeIDs.push_back(nodeID);
        }
        aSurfaceMeshElement.ID = nme.elementID;
        vecSurfaceMeshElements.push_back(aSurfaceMeshElement);
    }

    //! -----------------------------------
    //! build the surface mesh data source
    //! -----------------------------------
    outputSurfaceMeshDS = new Ng_MeshVS_DataSource2D(vecSurfaceMeshElements, vecSurfaceMeshPoints);
    //cout<<"NettgenTool2::performBrep()->____number of surface mesh points: "<<vecSurfaceMeshPoints.size()<<"____"<<endl;
    //cout<<"NettgenTool2::performBrep()->____number of surface mesh elements: "<<vecSurfaceMeshElements.size()<<"____"<<endl;

    if(outputSurfaceMeshDS.IsNull())
    {
        mr.isDone = false;
        mr.message = "cannot generate the surface mesh data source";
        return mr;
    }

    //! ---------------------------------
    //! build the face mesh data sources
    //! ---------------------------------
    for(int faceNr = 1; faceNr<=faceMeshes.size(); faceNr++)
    {
#ifdef SAVE_MESH_FILES
        char name[128];
        sprintf(name,"D:\\faceNr_%d.txt",faceNr);
        FILE *f = fopen(name,"w");
        fprintf(f,"\\workbench\\\n");
#endif
        const std::pair<std::vector<Ng_meshPoint>,std::vector<Ng_surfaceMeshElement>> &aFaceMesh = faceMeshes.at(faceNr-1);
        cout<<"____face nr: "<<faceNr<<" number of points: "<<aFaceMesh.first.size()<<"____"<<endl;
        cout<<"____face nr: "<<faceNr<<" number of elements: "<<aFaceMesh.second.size()<<"____"<<endl;

        const std::vector<Ng_meshPoint> &faceMeshPoints = aFaceMesh.first;
        const std::vector<Ng_surfaceMeshElement> &faceMeshElements = aFaceMesh.second;

        if(faceMeshPoints.size() == 0 || faceMeshElements.size() ==0)
        {
            cout<<"NettgenTool2::performBrep()->____warning: the mesh data source for face: "<<faceNr<<" has not been generated____"<<endl;
            continue;
        }

        //! -----------------------------
        //! convert into mesh::meshPoint
        //! -----------------------------
        std::vector<mesh::meshPoint> meshPoints;
        for(int n=0; n<faceMeshPoints.size(); n++)
        {
            const Ng_meshPoint &nmp = faceMeshPoints.at(n);
            mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
            meshPoints.push_back(aMeshPoint);
#ifdef SAVE_MESH_FILES
            fprintf(f,"%d\t%lf\t%lf\t%lf\n",nmp.nodeID,nmp.x,nmp.y,nmp.z);
#endif
        }
        //! -------------------------------
        //! convert into mesh::meshElement
        //! -------------------------------
        std::vector<mesh::meshElement> meshElements;
        for(int n=0; n<faceMeshElements.size(); n++)
        {
            mesh::meshElement meshElement;
            const Ng_surfaceMeshElement &nme = faceMeshElements.at(n);
            meshElement.ID = nme.elementID;
            int NbNodes = 0;
            switch(nme.type)
            {
                case NG_TRIG: meshElement.type = TRIG; NbNodes = 3; break;
                case NG_TRIG6: meshElement.type = TRIG6; NbNodes = 6; break;
                case NG_QUAD: meshElement.type = QUAD; NbNodes = 4; break;
                case NG_QUAD6: meshElement.type = QUAD6; NbNodes = 6; break;
                case NG_QUAD8: meshElement.type = QUAD8; NbNodes = 8; break;
            }
            for(int k=0; k<NbNodes; k++)
            {
                int nodeID = nme.nodeIDs[k];
                meshElement.theNodeIDs.push_back(nodeID);
#ifdef SAVE_MESH_FILES
                fprintf(f,"%d\t",nodeID);
#endif
            }
#ifdef SAVE_MESH_FILES
            fprintf(f,"\n");
#endif
            meshElements.push_back(meshElement);
        }

        //cout<<"____face nr: "<<faceNr<<" number of points: "<<meshPoints.size()<<"____"<<endl;
        //cout<<"____face nr: "<<faceNr<<" number of elements: "<<meshElements.size()<<"____"<<endl;

#ifdef SAVE_MESH_FILES
        fclose(f);
#endif
        occHandle(Ng_MeshVS_DataSourceFace) faceMeshDS = new Ng_MeshVS_DataSourceFace(meshElements,meshPoints);

        //cout<<"NettgenTool2::performBrep()->____face mesh nr: "<<faceNr<<
        //      " nodes: "<<faceMeshDS->GetAllNodes().Extent()<<
        //      " elements: "<<faceMeshDS->GetAllElements().Extent()<<"____"<<endl;

        myMDB->ArrayOfMeshDSOnFaces.setValue(bodyIndex,faceNr,faceMeshDS);
    }

    if(isVolume)
    {
        //! -----------------------------
        //! convert into mesh::meshPoint
        //! -----------------------------
        std::vector<mesh::meshPoint> vecVolumeMeshPoints;
        for(int n = 0; n<volumeMeshPoints.size(); n++)
        {
            const Ng_meshPoint &nmp = volumeMeshPoints.at(n);
            mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
            vecVolumeMeshPoints.push_back(aMeshPoint);
        }

        //! -------------------------------
        //! convert into mesh::meshElement
        //! -------------------------------
        std::vector<mesh::meshElement> vecVolumeMeshElements;
        for(int n=0; n<volumeMeshElements.size(); n++)
        {
            const Ng_volumeMeshElement &nve = volumeMeshElements.at(n);
            mesh::meshElement aVolumeMeshElement;
            int NbNodes = 0;

            switch(nve.type)
            {
            case NG_TET:
            {
                NbNodes = 4;
                aVolumeMeshElement.type = TET;
            }
                break;
            case NG_TET10:
            {
                NbNodes = 10;
                aVolumeMeshElement.type = TET10;
                //! currently the netgen mesher is used only for
                //! generating first order grids
            }
                break;
            case NG_PYRAMID:
            {
                NbNodes = 5;
                aVolumeMeshElement.type = PYRAM;
                //! currently this element is not generated by netgen
            }
                break;
            case NG_PRISM:
            {
                NbNodes = 6;
                aVolumeMeshElement.type = PRISM;
                //! currently this element is not generated by netgen
            }
                break;
            }
            //! ----------------------
            //! add the element nodes
            //! ----------------------
            for(int k=0; k<NbNodes; k++)
            {
                int nodeID = nve.nodeIDs.at(k);
                aVolumeMeshElement.theNodeIDs.push_back(nodeID);
            }
            aVolumeMeshElement.ID = n+1;
            vecVolumeMeshElements.push_back(aVolumeMeshElement);
        }

        outputVolumeMeshDS = new Ng_MeshVS_DataSource3D(vecVolumeMeshElements, vecVolumeMeshPoints);

        if(outputVolumeMeshDS.IsNull())
        {
            mr.isDone = true;
            mr.message = "error in generating the volume mesh data source";
            return mr;
        }
        mr.isDone = true;
        mr.message = QString("The mesh has been successfully generated");
        return mr;
    }

    mr.isDone = true;
    mr.message = QString("The mesh has been successfully generated");
    return mr;
}

//#ifdef HANDLE_NGLIB_SYSTEM_EXCEPTIONS
//! ------------------------------
//! function: SystemErrorFunction
//! details:
//! ------------------------------
bool NettgenTool2::SystemErrorFunction(STLMeshing_InOutParameters inOutParameters)
{
    __try
    {
        //! ------
        //! input
        //! ------
        bool isVolume = inOutParameters.isVolume;
        void *netgenTessellation = inOutParameters.netgenTessellation;
        void *externallyDefinedEdges = inOutParameters.externallyDefinedEdges;
        Ng_Meshing_Parameters *mp = inOutParameters.meshingParameters;
        void *localMeshSizingControls = inOutParameters.localMeshSizingControls;

        //! --------
        //! outputs
        //! --------
        void *surfaceMeshPointsP = inOutParameters.surfaceMeshPointsP;
        void *surfaceMeshElementsP = inOutParameters.surfaceMeshElementsP;
        void *volumeMeshPointsP = inOutParameters.volumeMeshPointsP;
        void *volumeMeshElementsP = inOutParameters.volumeMeshElementsP;
        void *surfaceMeshDataP = inOutParameters.surfaceMeshDataP;
        void *unassociatedSurfaceElements = inOutParameters.unassociatedSurfaceElements;

        bool isDone = Ng_STL_buildMesh(isVolume,
                                       netgenTessellation,
                                       externallyDefinedEdges,
                                       mp,
                                       localMeshSizingControls,
                                       surfaceMeshPointsP,
                                       surfaceMeshElementsP,
                                       volumeMeshPointsP,
                                       volumeMeshElementsP,
                                       surfaceMeshDataP,
                                       unassociatedSurfaceElements);

        return isDone;

        cout<<"NettgenTool2::SystemErrorFunction()->____in try: volume meshing done____"<<endl;
    }
    __finally
    {
        cout<<"NettgenTool2::SystemErrorFunction()->____in finally____"<<endl;
    }
}

//! --------------------------------
//! function: SystemErrorFunction_1
//! details:
//! --------------------------------
bool NettgenTool2::SystemErrorFunction_1(BRepMeshing_InOutParameters inOutParameters)
{
    __try
    {
        //! -------
        //! inputs
        //! -------
        bool isVolume = inOutParameters.isVolume;
        void *shape = inOutParameters.shape;
        void *validFaceTags = inOutParameters.validFaceTags;    //! unused
        Ng_Meshing_Parameters *mp = inOutParameters.mp;
        void *localMeshSizingControls = inOutParameters.localMeshSizingControls;
        //! --------
        //! outputs
        //! --------
        void *surfaceMeshPointsP = inOutParameters.surfaceMeshPointsP;
        void *surfaceMeshElementsP = inOutParameters.surfaceMeshElementsP;
        void *volumeMeshPointsP = inOutParameters.volumeMeshPointsP;
        void *volumeMeshElementsP = inOutParameters.volumeMeshElementsP;
        void *faceMeshesP = inOutParameters.faceMeshesP;

        bool isDone = Ng_OCC_buildMesh(isVolume,
                                       shape,
                                       validFaceTags,
                                       mp,
                                       localMeshSizingControls,
                                       surfaceMeshPointsP,
                                       surfaceMeshElementsP,
                                       volumeMeshPointsP,
                                       volumeMeshElementsP,
                                       faceMeshesP);

        return isDone;

        cout<<"NettgenTool2::SystemErrorFunction_1()->____in try: volume meshing done____"<<endl;
    }
    __finally
    {
        cout<<"NettgenTool2::SystemErrorFunction_1()->____in finally____"<<endl;
    }
}

//! --------------------------------
//! function: SystemErrorFunction_2
//! details:
//! --------------------------------
bool NettgenTool2::SystemErrorFunction_2(meshing_InOutParameters inOutParameters)
{
    __try
    {
        //! -------
        //! inputs
        //! -------
        void *surfaceMeshPointsP = inOutParameters.inputSurfaceMeshPoints;
        void *surfaceMeshElementsP = inOutParameters.inputSurfaceMeshElements;
        Ng_Meshing_Parameters *mp = inOutParameters.mp;

        //! --------
        //! outputs
        //! --------
        void *volumeMeshPointsP = inOutParameters.volumeMeshPointsP;
        void *volumeMeshElementsP = inOutParameters.volumeMeshElementsP;

        bool isDone = Ng_buildMeshFromSurfaceMesh(surfaceMeshPointsP,
                                                  surfaceMeshElementsP,
                                                  mp,
                                                  volumeMeshPointsP,
                                                  volumeMeshElementsP);

        cout<<"NettgenTool2::SystemErrorFunction_2()->____in try: volume meshing done____"<<endl;
        return isDone;
    }
    __finally
    {
        cout<<"NettgenTool2::SystemErrorFunction_2()->____in finally____"<<endl;
    }
}
//#endif

//! ------------------------------------
//! function: meshVolumeFromSurfaceMesh
//! details:
//! ------------------------------------
userMessage NettgenTool2::meshVolumeFromSurfaceMesh(int bodyIndex,
                                                    const occHandle(MeshVS_DataSource) &aSurfaceMeshDS,
                                                    occHandle(MeshVS_DataSource) &outputVolumeMeshDS)
{
    cout<<"NettgenTool2::meshVolumeFromSurfaceMesh()->____function called on body index: "<<bodyIndex<<"____"<<endl;

    //! ---------------------------------
    //! disable stop during sanity check
    //! and surface mesh preparation
    //! ---------------------------------
    if(myProgressIndicator!=Q_NULLPTR) emit requestDisableStop();

    //! -------------
    //! sanity check
    //! -------------
    if(aSurfaceMeshDS.IsNull())
    {
        userMessage mr(false,QString("Cannot generate the volume mesh from the post inflation mesh. The input surface mesh is null"));
        return mr;
    }

    if(aSurfaceMeshDS->GetAllNodes().Extent()<3)
    {
        userMessage mr(false,QString("Cannot generate the volume mesh from the post inflation mesh. The input surface mesh is not valid"));
        return mr;
    }

    if(aSurfaceMeshDS->GetAllElements().Extent()<4)
    {
        userMessage mr(false,QString("Cannot generate the volume mesh from the post inflation mesh. The input surface mesh is open"));
        return mr;
    }

    //! ---------------
    //! meshing result
    //! ---------------
    userMessage mr(false,"");

    //! ----------------------
    //! send a progress event
    //! ----------------------
    QString task = "Netgen meshing";
    if(myProgressIndicator!=Q_NULLPTR)
    {
        QProgressEvent *progressEvent = new QProgressEvent(QProgressEvent_None,0,9999,0,"",QProgressEvent_Init,0,100,0,task);
        QApplication::postEvent(myProgressIndicator,progressEvent);
        cout<<"____tag03____"<<endl;
    }

    //! ------------------------------------------------------------
    //! prepare the surface mesh input: add the surface mesh points
    //! ------------------------------------------------------------
    std::vector<Ng_meshPoint> vecSurfaceMeshPoints;
    TColStd_IndexedMapOfInteger indexedNodeMap;
    for(TColStd_MapIteratorOfPackedMapOfInteger anIter(aSurfaceMeshDS->GetAllNodes());anIter.More();anIter.Next())
    {
        int nodeID = anIter.Key();
        indexedNodeMap.Add(nodeID);

        int NbNodes;
        double buf[3];
        TColStd_Array1OfReal coords(*buf,1,3);
        MeshVS_EntityType atype;
        if(!aSurfaceMeshDS->GetGeom(nodeID,false,coords,NbNodes,atype)) continue;
        Ng_meshPoint aP(coords(1),coords(2),coords(3),nodeID);
        vecSurfaceMeshPoints.push_back(aP);
    }

    //! --------------------------------------------------------------
    //! prepare the surface mesh input: add the surface mesh elements
    //! --------------------------------------------------------------
    std::vector<Ng_surfaceMeshElement> vecSurfaceMeshElements;
    for(TColStd_MapIteratorOfPackedMapOfInteger anIter(aSurfaceMeshDS->GetAllElements());anIter.More();anIter.Next())
    {
        int eID = anIter.Key();
        int nbuf[3];
        TColStd_Array1OfInteger NodeIDs(*nbuf,1,3);
        int NbNodes;
        if(!aSurfaceMeshDS->GetNodesByElement(eID,NodeIDs,NbNodes)) continue;

        Ng_surfaceMeshElement anElement;
        anElement.elementID = eID;
        for(int i=0; i<NbNodes; i++) anElement.nodeIDs.push_back(indexedNodeMap.FindIndex(NodeIDs.Value(i+1)));
        anElement.type = NG_TRIG;

        vecSurfaceMeshElements.push_back(anElement);
    }

    //! -----------------------------------------------------------
    //! init the meshing parameters
    //! the global meshing parameters read from the mesh data base
    //! -----------------------------------------------------------
    Ng_Meshing_Parameters mp = initNetgenMeshingParameters();
    mp.grading = myMDB->ArrayOfGradingValue.value(bodyIndex);
    mp.minh = myMDB->ArrayOfMinBodyElementSize.value(bodyIndex);
    mp.maxh = myMDB->ArrayOfMaxBodyElementSize.value(bodyIndex);
    //! -------
    //! inputs
    //! -------
    meshing_InOutParameters inOutParameters;
    inOutParameters.inputSurfaceMeshPoints = (void*)(&vecSurfaceMeshPoints);
    inOutParameters.inputSurfaceMeshElements = (void*)(&vecSurfaceMeshElements);
    inOutParameters.mp = &mp;

    //! --------
    //! outputs
    //! --------
    std::vector<Ng_meshPoint> volumeMeshPoints;
    std::vector<Ng_volumeMeshElement> volumeMeshElements;
    inOutParameters.volumeMeshPointsP = (void*)(&volumeMeshPoints);
    inOutParameters.volumeMeshElementsP = (void*)(&volumeMeshElements);

    //! ------------
    //! enable stop
    //! ------------
    if(myProgressIndicator!=Q_NULLPTR) emit requestEnableStop();

    bool isDone = false;
    try
    {
        _set_se_translator(trans_func_N);
        isDone = SystemErrorFunction_2(inOutParameters);
    }
    catch(SE_Exception e)
    {
        cout<<"NettgenTool2::meshVolumeFromSurfaceMesh()->____Netgen system error while generating the volume mesh____"<<endl;
        mr.isDone = false;
        mr.message = QString("Netgen system error while generating the volume mesh");
        return mr;
    }
    catch(...)
    {
        cout<<"NettgenTool2::meshVolumeFromSurfaceMesh()->____Netgen error while generating the volume mesh____"<<endl;
        mr.isDone = false;
        mr.message = QString("Netgen error while generating the volume mesh");
        return mr;
    }
    if(!isDone)
    {
        mr.isDone = false;
        mr.message = QString("Netgen error while generating the volume mesh");
        return mr;
    }

    //! -----------------------------
    //! convert into mesh::meshPoint
    //! -----------------------------
    std::vector<mesh::meshPoint> vecVolumeMeshPoints;
    for(int n = 0; n<volumeMeshPoints.size(); n++)
    {
        const Ng_meshPoint &nmp = volumeMeshPoints.at(n);
        mesh::meshPoint aMeshPoint(nmp.x,nmp.y,nmp.z,nmp.nodeID);
        vecVolumeMeshPoints.push_back(aMeshPoint);
    }

    //! -------------------------------
    //! convert into mesh::meshElement
    //! -------------------------------
    std::vector<mesh::meshElement> vecVolumeMeshElements;
    for(int n=0; n<volumeMeshElements.size(); n++)
    {
        const Ng_volumeMeshElement &nve = volumeMeshElements.at(n);
        mesh::meshElement aVolumeMeshElement;
        int NbNodes = 0;

        switch(nve.type)
        {
        case NG_TET:
        {
            NbNodes = 4;
            aVolumeMeshElement.type = TET;
        }
            break;
        case NG_TET10:
        {
            NbNodes = 10;
            aVolumeMeshElement.type = TET10;
            //! currently the netgen mesher is used only for
            //! generating first order grids
        }
            break;
        case NG_PYRAMID:
        {
            NbNodes = 5;
            aVolumeMeshElement.type = PYRAM;
            //! currently this element is not generated by netgen
        }
            break;
        case NG_PRISM:
        {
            NbNodes = 6;
            aVolumeMeshElement.type = PRISM;
            //! currently this element is not generated by netgen
        }
            break;
        }
        //! ----------------------
        //! add the element nodes
        //! ----------------------
        for(int k=0; k<NbNodes; k++)
        {
            int nodeID = nve.nodeIDs.at(k);
            aVolumeMeshElement.theNodeIDs.push_back(nodeID);
        }
        aVolumeMeshElement.ID = n+1;
        vecVolumeMeshElements.push_back(aVolumeMeshElement);
    }

    outputVolumeMeshDS = new Ng_MeshVS_DataSource3D(vecVolumeMeshElements, vecVolumeMeshPoints);

    if(outputVolumeMeshDS.IsNull())
    {
        mr.isDone = true;
        mr.message = "Error in generating the volume mesh data source";
        return mr;
    }

    mr.isDone = true;
    mr.message = QString("Netgen has successfully generated the volume mesh");
    return mr;
}

